<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Team 2481 Web Dashboard</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#positionData {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
		</style>
	</head>
	<body>
		<div id="positionData"></div>

		<script src="three.min.js"></script>
		<script src="js/loaders/STLLoader.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/WebGL.js"></script>
		<script src="/networktables/networktables.js" onerror="onLoadNTFailed()"></script>

		<script>
			if (WEBGL.isWebGLAvailable() === false)
			{
				document.body.appendChild(WEBGL.getWebGLErrorMessage());
			}

			//Enabling this disables animation and allows meshes to be moved around with the mouse
			var EDIT_MODE = false;

			var container;
			var camera, cameraTarget, scene, renderer, controls, axesHelper;
			var meshLoader, meshes;
			var intersectPlane, selection, raycaster, offset;

			//Specify object locations and rotations globally here.  This allows us to change locations by offsets from NetworkTables in animation
			var robotFrame, cargoIntakeAssembly, elevatorBase, elevatorMid, elevatorTop, hatchSlide;

			var framePos = new THREE.Vector3(0, 0, 0);
			var intakePos = new THREE.Vector3(-2.508141780271359, 10.230085621335952, -0.10246555939861768);
			var elevatorBasePos = new THREE.Vector3(0.03925090690609334, 5.475468811153478, 27.381542591082276);
			//Offsets for components that are attached to other moving components
			var elevatorMidOffset = new THREE.Vector3(0.0, 0.0, 0.0);
			var elevatorTopOffset = new THREE.Vector3(0.0, 0.0, 0.0);
			var hatchSlideOffset = new THREE.Vector3(5.908163308124815, 0.0, 0.0);

			var frameRot = new THREE.Euler(-Math.PI/2, 0, 0);
			var intakeRot = new THREE.Euler(-Math.PI/2, 0, 0);
			var elevatorBaseRot = new THREE.Euler(-Math.PI/2, 0, Math.PI);
			var elevatorMidRot = new THREE.Euler(-Math.PI/2, 0, Math.PI);
			var elevatorTopRot = new THREE.Euler(-Math.PI/2, 0, Math.PI);
			var hatchSlideRot = new THREE.Euler(-Math.PI/2, 0, Math.PI);

			init();
			animate();

			function init()
			{
				container = document.createElement('div');
				document.body.appendChild(container);

				camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 1500);
				camera.position.set(125, 100, 125);

				cameraTarget = new THREE.Vector3(0, 20.0, 0);

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0x940000);
				scene.fog = new THREE.Fog(0x940000, 300, 700);

				// Ground
				var plane = new THREE.Mesh(
					new THREE.PlaneBufferGeometry(1500, 1500),
					new THREE.MeshBasicMaterial({ color: 0x000000 })
				);
				plane.rotation.x = -Math.PI / 2;
				plane.position.y = -50.0;
				scene.add(plane);

				// Model loading
				meshes = [];
				meshLoader = new THREE.STLLoader();
				
				meshLoader.load('./RobotModels/FrameParts.stl', function (geometry) {
					robotFrame = addMesh(geometry, framePos, frameRot);
				});

				meshLoader.load('./RobotModels/BallIntakeAssembly.stl', function (geometry) {
					cargoIntakeAssembly = addMesh(geometry, intakePos, intakeRot);
				});

				meshLoader.load('./RobotModels/ElevatorBase.stl', function (geometry) {
					elevatorBase = addMesh(geometry, elevatorBasePos, elevatorBaseRot);
				});

				meshLoader.load('./RobotModels/ElevatorMid.stl', function (geometry) {
					var elevatorMidPos = new THREE.Vector3();
					elevatorMidPos.addVectors(elevatorBasePos, elevatorMidOffset);
					elevatorMid = addMesh(geometry, elevatorMidPos, elevatorMidRot);
				});

				meshLoader.load('./RobotModels/ElevatorTop.stl', function (geometry) {
					var elevatorTopPos = new THREE.Vector3();
					elevatorTopPos.addVectors(elevatorMid.position, elevatorTopOffset);
					elevatorTop = addMesh(geometry, elevatorTopPos, elevatorTopRot);
				});

				meshLoader.load('./RobotModels/HatchSlide.stl', function (geometry) {
					var hatchSlidePos = new THREE.Vector3();
					hatchSlidePos.addVectors(elevatorTop.position, hatchSlideOffset);
					hatchSlide = addMesh(geometry, hatchSlidePos, hatchSlideRot);
				});

				// Lights
				scene.add(new THREE.HemisphereLight(0xffffff, 0x000000));
				var dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
				dirLight.position.set(250, 250, 0);
				scene.add(dirLight);

				// Plane that helps to determine an intersection position
				intersectPlane = new THREE.Mesh(new THREE.PlaneBufferGeometry(5000, 5000, 8, 8), new THREE.MeshBasicMaterial({color: 0xffffff, visible: false}));
				scene.add(intersectPlane);

				// Objects for helping with dragging and dropping meshes
				raycaster = new THREE.Raycaster();
				offset = new THREE.Vector3();

				// World renderer
				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);

				renderer.gammaInput = true;
				renderer.gammaOutput = true;

				container.appendChild(renderer.domElement);

				axesHelper = new THREE.AxesHelper(50);
				scene.add(axesHelper);

				// Orbital controls for rotating and panning camera
				controls = new THREE.OrbitControls(camera, renderer.domElement);

				window.addEventListener('resize', onWindowResize, false);
				window.addEventListener("keydown", onKeyPressed, false);
				window.addEventListener('mousedown', onDocumentMouseDown, false);
        		window.addEventListener('mousemove', onDocumentMouseMove, false);
				window.addEventListener('mouseup', onDocumentMouseUp, false);

				try
				{
					NetworkTables.addWsConnectionListener(function(connected) {
      					console.log("Websocket connected: " + connected);
  					}, true);
				} catch(e) {}
			}

			function addMesh(geometry, position, rotation)
			{
				// Create different materials for each mesh so we can change them (and their colors) individually
				var meshMaterial = new THREE.MeshPhongMaterial({ color: 0xaaaaaa, specular: 0x111111, shininess: 200 });
				newMesh = new THREE.Mesh(geometry, meshMaterial);

				newMesh.rotation.copy(rotation);
				newMesh.position.copy(position);
					
				newMesh.originalPosition = position;
				meshes.push(newMesh);

				scene.add(newMesh);

				return newMesh;
			}

			function onWindowResize()
			{
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function onDocumentMouseDown(event)
			{
				if(!EDIT_MODE) return;

				// Get mouse position
  				var mouseX = (event.clientX / window.innerWidth) * 2 - 1;
  				var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
  				// Get 3D vector from 3D mouse position using 'unproject' function
  				var vector = new THREE.Vector3(mouseX, mouseY, 1);
  				vector.unproject(camera);
  				// Set the raycaster position
  				raycaster.set(camera.position, vector.sub(camera.position).normalize());
  				// Find all intersected objects
  				var intersects = raycaster.intersectObjects(meshes);
  				if (intersects.length > 0) {
    				// Disable the controls
					controls.enableRotate = false;
    				// Set the selection - first intersected object
    				selection = intersects[0].object;
    				// Calculate the offset
    				var pIntersects = raycaster.intersectObject(intersectPlane);
    				offset.copy(pIntersects[0].point).sub(intersectPlane.position);
  				}
			}

			function onDocumentMouseMove(event)
			{
				if(!EDIT_MODE) return;

  				event.preventDefault();
  				// Get mouse position
  				var mouseX = (event.clientX / window.innerWidth) * 2 - 1;
  				var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
  				// Get 3D vector from 3D mouse position using 'unproject' function
  				var vector = new THREE.Vector3(mouseX, mouseY, 1);
  				vector.unproject(camera);
  				// Set the raycaster position
  				raycaster.set(camera.position, vector.sub(camera.position).normalize());
  				if (selection)
				{
					controls.enableRotate = false;
    				// Check the position where the plane is intersected
    				var intersects = raycaster.intersectObject(intersectPlane);
    				// Reposition the object based on the intersection point with the plane
    				selection.position.copy(intersects[0].point.sub(offset));
  				}
				else
				{
					controls.enableRotate = true;
    				// Update position of the plane to always face the camera
    				var intersects = raycaster.intersectObjects(meshes);
    				if (intersects.length > 0)
					{
      					intersectPlane.position.copy(intersects[0].object.position);
      					intersectPlane.lookAt(camera.position);
    				}	
  				}
			}

			function onDocumentMouseUp(event)
			{
				if(!EDIT_MODE) return;

				if(selection != null && selection != undefined)
				{
					// With orbital controls, right-clicking to get to the console doesn't work (since right-clicking is panning)
					// So instead put the location data in a div at the top of the screen
					document.getElementById("positionData").innerHTML = selection.position.x + ", " + selection.position.y + ", " + selection.position.z;
				}
				// Enable the controls
				controls.enableRotate = true;
				selection = null;
			}

			function onLoadNTFailed()
			{
				alert("Could not load Network Tables library, animation will not be available.  Did you access this page through the py2networktablesjs server?\nRun py2networktablesjs and navigate to http://127.0.0.1:8888");
			}

			function onKeyPressed(event)
			{
				if(event.ctrlKey && event.shiftKey && event.code == "KeyE")
				{
					EDIT_MODE = !EDIT_MODE;

					if(EDIT_MODE)
						resetMeshPositions();
					else
						setMeshOriginalPositions();
				}
			}

			function setMeshOriginalPositions()
			{
				for(var i=0; i<meshes.length; i++)
				{
					meshes[i].originalPosition.copy(meshes[i].position);
				}
			}

			function resetMeshPositions()
			{
				for(var i=0; i<meshes.length; i++)
				{
					meshes[i].position.copy(meshes[i].originalPosition);
				}
			}

			function animate()
			{
				var ntElevatorSlidePos, ntElevatorPos, ntHatchSlidePos;
				try
				{
					// Set sky color depending on whether Network Tables is connected
					if(NetworkTables.isRobotConnected())
					{
						scene.background.set(0x009400);
						scene.fog.color.set(0x009400);
					}
					else
					{
						scene.background.set(0x940000);
						scene.fog.color.set(0x940000);
					}

					ntElevatorSlidePos = NetworkTables.getValue("/SmartDashboard/ElevatorSlidePosition", 0.0);
					ntElevatorPos = NetworkTables.getValue("/SmartDashboard/ElevatorPosition", 0.0);
					ntHatchSlidePos = NetworkTables.getValue("/SmartDashboard/HatchSlidePosition", 0.0);
				}
				catch(e)
				{
					scene.background.set(0x940000);
					scene.fog.color.set(0x940000);
				}

				// No animation in edit mode, makes it difficult to grab onto meshes and move them
				if(!EDIT_MODE)
				{
					axesHelper.visible = false;

					try
					{
						elevatorBase.position.setZ(elevatorBasePos.z - ntElevatorSlidePos);

						var newElevatorMidPos = new THREE.Vector3();
						newElevatorMidPos.addVectors(elevatorBase.position, elevatorMidOffset);
						newElevatorMidPos.setY(newElevatorMidPos.y + ntElevatorPos/2.0);
						elevatorMid.position.copy(newElevatorMidPos);

						var newElevatorTopPos = new THREE.Vector3();
						newElevatorTopPos.addVectors(elevatorMid.position, elevatorTopOffset);
						newElevatorTopPos.setY(newElevatorTopPos.y + ntElevatorPos/2.0);
						elevatorTop.position.copy(newElevatorTopPos);

						var newHatchSlidePos = new THREE.Vector3();
						newHatchSlidePos.addVectors(elevatorTop.position, hatchSlideOffset);
						newHatchSlidePos.setX(newHatchSlidePos.x - ntHatchSlidePos);
						hatchSlide.position.copy(newHatchSlidePos);

						// This was a test of dynamically changing the color of a material based off data from Network Tables
						/*if(pos > 3.0)
							elevatorAssembly.material.color.set(0x0000ff);
						else
							elevatorAssembly.material.color.set(0x00ff00);*/
					}
					catch(e)
					{
						// One of the meshes hasn't loaded yet, no need to crash and burn... just wait and the model will load soon
					}
				}
				else
				{
					axesHelper.visible = true;
				}
				
				requestAnimationFrame(animate);

				render();
			}

			function render()
			{
				controls.update();

				renderer.render(scene, camera);
			}

		</script>
	</body>
</html>
