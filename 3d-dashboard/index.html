<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Team 2481 Web Dashboard</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#positionData {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}

			#cameracontainer {
    			position:absolute;
				top: 0%;
				left: 40%;
				width: 60%;
				height: 60%;
    			z-index:5;
				border-style: solid;
				border-color: #333333;
			}

			/* The Modal (background) */
			.modal {
  				display: none; /* Hidden by default */
  				position: fixed; /* Stay in place */
  				z-index: 10; /* Sit on top */
  				left: 0;
  				top: 0;
  				width: 100%; /* Full width */
  				height: 100%; /* Full height */
  				overflow: auto; /* Enable scroll if needed */
  				background-color: rgb(0,0,0); /* Fallback color */
  				background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
			}

				/* Modal Content/Box */
				.modal-content {
  				background-color: #fefefe;
  				margin: 15% auto; /* 15% from the top and centered */
  				padding: 20px;
  				border: 1px solid #888;
  				width: 80%; /* Could be more or less, depending on screen size */
			}

			/* The Close Button */
			.close {
  				color: #aaa;
  				float: right;
  				font-size: 28px;
  				font-weight: bold;
			}

			.close:hover,
			.close:focus {
  				color: black;
  				text-decoration: none;
  				cursor: pointer;
			} 
		</style>
	</head>
	<body>
		<div id="positionData"></div>

		<div id="modalData" class="modal">
			<!-- Modal content -->
			<div id="modalContent" class="modal-content">
			</div>
		</div>

		<div id="world">
			<div id="cameracontainer">
				<img id="camera" width="100%" height="100%">
			</div>
		</div>

		<script src="three.min.js"></script>
		<script src="camera.js"></script>
		<script src="js/loaders/STLLoader.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/objects/Reflector.js"></script>
		<script src="js/WebGL.js"></script>
		<script src="/networktables/networktables.js" onerror="onLoadNTFailed()"></script>

		<script>
			if (WEBGL.isWebGLAvailable() === false)
			{
				document.body.appendChild(WEBGL.getWebGLErrorMessage());
			}

			//Enabling this disables animation and allows meshes to be moved around with the mouse
			var EDIT_MODE = false;

			var container;
			var camera, camera2, cameraTarget, scene, renderer, controls, axesHelper;
			var meshLoader, meshes;
			var plane;
			var intersectPlane, selection, raycaster, offset;

			//Specify object locations and rotations globally here.  This allows us to change locations by offsets from NetworkTables in animation
			var numMeshes = 10; //6 robot components, 1 cargo, 1 hatch panel, 2 line strips
			var robotFrame, cargoIntakeAssembly, elevatorBase, climberBase, climberSlide, elevatorMid, elevatorTop, hatchSlide;
			var swerveModuleFL, swerveModuleFR, swerveModuleBL, swerveModuleBR;
			var swerveWheelFL, swerveWheelFL, swerveWheelBL, swerveWheelBR;
			var cargo, hatchPanel, lineStrip1, lineStrip2;

			var framePos = new THREE.Vector3(0, 0, 28.0);
			var intakePos = new THREE.Vector3(-2.504312031976717, -7.969516986852309, 27.44642744606611);
			var elevatorBasePos = new THREE.Vector3(-0.057937102316749645, 4.6878697981700626, 23.362945503299855);
			var climberBasePos = new THREE.Vector3(0.6284390907759532, -6.15211443760683, 9.261296229358493);
			var climberSlidePos = new THREE.Vector3(0.6284390907759532, 3.8, 9.261296229358493);
			//Offsets for components that are attached to other moving components
			var elevatorMidOffset = new THREE.Vector3(0.0, -2.0, 0.0);
			var elevatorTopOffset = new THREE.Vector3(0.0, 0.0, 0.0);
			var hatchSlideOffset = new THREE.Vector3(6.0, 0, 0); //15.308163308124815, 0.0, 0.0);

			var frameRot = new THREE.Euler(-Math.PI/2, 0, Math.PI);
			var intakeRot = new THREE.Euler(-Math.PI/2, 0, Math.PI);
			var elevatorBaseRot = new THREE.Euler(-Math.PI/2, 0, Math.PI);
			var climberRot = new THREE.Euler(-Math.PI/2, 0, -Math.PI/2);
			var elevatorMidRot = new THREE.Euler(-Math.PI/2, 0, Math.PI);
			var elevatorTopRot = new THREE.Euler(-Math.PI/2, 0, Math.PI);
			var hatchSlideRot = new THREE.Euler(-Math.PI/2, 0, Math.PI);

			var cargoOffset = new THREE.Vector3(-5.804175389054878, 15.1146, 8.37987);
			var hatchOffset = new THREE.Vector3(-5.804175389054878, 15.1146, 8.37987);
			var lineStripPos = new THREE.Vector3(0.0, -5.0, 15.0);

			var swerveModuleFLPos = new THREE.Vector3(15.630745350994776, 3.1694138066706206, 27.802808952662385);
			var swerveModuleFLRot = new THREE.Euler(-Math.PI/2, 0, -Math.PI/2);
			var swerveWheelFLPos = new THREE.Vector3(13.058864366633356, 2.659921031798123, 25.572273133566558);
			var swerveWheelFLRot = new THREE.Euler(-Math.PI/2, 0, 0);

			var swerveModuleFRPos = new THREE.Vector3(-15.630745350994776, 3.1694138066706206, 22.87218119260358);
			var swerveModuleFRRot = new THREE.Euler(-Math.PI/2, 0, Math.PI/2);
			var swerveWheelFRPos = new THREE.Vector3(-13.219783757639426, 2.5376285000501793, 25.114428574505666);
			var swerveWheelFRRot = new THREE.Euler(-Math.PI/2, 0, 0);

			var swerveModuleBLPos = new THREE.Vector3(15.630745350994776, 3.1694138066706206, 0.0);
			var swerveModuleBLRot = new THREE.Euler(-Math.PI/2, 0, 0.0);
			var swerveWheelBLPos = new THREE.Vector3(13.383402787554738, 2.6076853004222817, 2.425312724324896);
			var swerveWheelBLRot = new THREE.Euler(-Math.PI/2, 0, 0.0);

			var swerveModuleBRPos = new THREE.Vector3(-10.249484988758901, 3.1694138066706206, 0.0);
			var swerveModuleBRRot = new THREE.Euler(-Math.PI/2, 0, 0.0);
			var swerveWheelBRPos = new THREE.Vector3(-12.561061581849016, 2.536020495364046, 2.504692059650495);
			var swerveWheelBRRot = new THREE.Euler(-Math.PI/2, 0, 0.0);

			var hatchDropOffPos = new THREE.Vector3(-0.488461512530038, 18.842034966644192, 38.89617339647177);
			var hatchDropOffRot = new THREE.Euler(-Math.PI/2, 0.0, Math.PI);

			//Variables for holding data from network tables for updating animations
			var ntIntakePos, ntElevatorPos, ntHatchSlidePos;
			var hasCargo, hasHatch, ntLineStrip1Pos, ntLineStrip2Pos;
			var flSteerEncoderConnected, frSteerEncoderConnected, blSteerEncoderConnected, brSteerEncoderConnected;
			var flSteerEncoderCalibrated, frSteerEncoderCalibrated, blSteerEncoderCalibrated, brSteerEncoderCalibrated;
			var flSteerEncoderPos, frSteerEncoderPos, blSteerEncoderPos, brSteerEncoderPos;
			var elevatorEncoderConnected, elevatorZeroed;
			var intakeEncoderConnected, intakeZeroed;
			var slideEncoderConnected, slideZeroed;
			var gyroYaw;
			var LL_ydist, LL_xdist, LL_skew, LL_vis, LL_tx, LL_ty;

			var modalContent = document.getElementById("modalContent");

			init();
			animate();

			function init()
			{
				//container = document.createElement('div');
				//document.body.appendChild(container);
				container = document.getElementById("world");

				camera = new THREE.PerspectiveCamera(35, (0.4*window.innerWidth) / window.innerHeight, 1, 1500);
				camera.position.set(145, 100, 145);
				cameraTarget = new THREE.Vector3(0, 30.0, 14);

				camera2 = new THREE.PerspectiveCamera(35, (0.6*window.innerWidth) / (0.4*window.innerHeight), 1, 1500);
				//camera2.position.set(0, -55, 14.0);
				camera2.position.set(0, 80.0, -50.0);
				camera2.lookAt(new THREE.Vector3(0.0, 35.0, 14.0));

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0x940000);
				scene.fog = new THREE.Fog(0x940000, 300, 700);

				// Ground
				plane = new THREE.Mesh(
					new THREE.PlaneBufferGeometry(1500, 1500),
					new THREE.MeshBasicMaterial({ color: 0x000000 })
				);
				plane.rotation.x = -Math.PI / 2;
				plane.position.y = -50.0;
				scene.add(plane);

				//Ground mirror
				mirrorGeo = new THREE.CircleBufferGeometry(50, 32);
				mirror = new THREE.Reflector(mirrorGeo, {
					clipBias: 0.003,
					textureWidth: window.innerWidth * window.devicePixelRatio,
					textureHeight: window.innerHeight * window.devicePixelRatio,
					color: 0x777777,
					recursion: 1
				} );
				mirror.position.y = -12.5;
				mirror.position.z = 14.0;
				mirror.rotation.x = -Math.PI / 2;
				scene.add( mirror );

				// Model loading
				meshes = [];
				meshLoader = new THREE.STLLoader();
				
				meshLoader.load('./RobotModels/FrameParts.stl', function (geometry) {
					robotFrame = addMesh(geometry, framePos, frameRot);
					robotFrame.name = "Frame";
					robotFrame.vars = ["gyroYaw"];
				});

				meshLoader.load('./RobotModels/BallIntakeAssembly.stl', function (geometry) {
					cargoIntakeAssembly = addMesh(geometry, intakePos, intakeRot);
					cargoIntakeAssembly.name = "Intake";
					cargoIntakeAssembly.vars = ["ntIntakePos", "intakeEncoderConnected", "intakeZeroed"];
				});

				meshLoader.load('./RobotModels/ElevatorBase.stl', function (geometry) {
					elevatorBase = addMesh(geometry, elevatorBasePos, elevatorBaseRot);
					elevatorBase.name = "Elevator";
					elevatorBase.vars = ["ntElevatorPos", "elevatorEncoderConnected", "elevatorZeroed"];
				});

				meshLoader.load('./RobotModels/ClimberBase.stl', function (geometry) {
					climberBase = addMesh(geometry, climberBasePos, climberRot);
					climberBase.name = "Climber";
				});

				meshLoader.load('./RobotModels/ClimberSlide.stl', function (geometry) {
					climberSlide = addMesh(geometry, climberSlidePos, climberRot);
					climberSlide.name = "Climber";
				});

				meshLoader.load('./RobotModels/ElevatorMid.stl', function (geometry) {
					var elevatorMidPos = new THREE.Vector3(0.0, 0.0, 0.0);
					elevatorMid = addMesh(geometry, elevatorMidPos, elevatorMidRot);
					elevatorMid.name = "Elevator";
					elevatorMid.vars = ["ntElevatorPos", "elevatorEncoderConnected", "elevatorZeroed"];
				});

				meshLoader.load('./RobotModels/ElevatorTop.stl', function (geometry) {
					var elevatorTopPos = new THREE.Vector3(0.0, 0.0, 0.0);
					elevatorTop = addMesh(geometry, elevatorTopPos, elevatorTopRot);
					elevatorTop.name = "Elevator";
					elevatorTop.vars = ["ntElevatorPos", "elevatorEncoderConnected", "elevatorZeroed"];
				});

				meshLoader.load('./RobotModels/HatchSlide.stl', function (geometry) {
					var hatchSlidePos = new THREE.Vector3(0.0, 0.0, 0.0);
					hatchSlide = addMesh(geometry, hatchSlidePos, hatchSlideRot);
					hatchSlide.name = "Hatch Slide";
					hatchSlide.vars = ["ntHatchSlidePos", "slideEncoderConnected", "slideZeroed"];
				});

				meshLoader.load('./RobotModels/SwerveModule.stl', function (geometry) {
					swerveModuleFL = addMesh(geometry, swerveModuleFLPos, swerveModuleFLRot);
					swerveModuleFL.name = "Swerve Drive";
					swerveModuleFL.vars = ["flSteerEncoderPos", "frSteerEncoderPos", "blSteerEncoderPos", "brSteerEncoderPos", "newLine", "flSteerEncoderConnected", "frSteerEncoderConnected", "blSteerEncoderConnected", "brSteerEncoderConnected", "newLine", "flSteerEncoderCalibrated", "frSteerEncoderCalibrated", "blSteerEncoderCalibrated", "brSteerEncoderCalibrated"];

					swerveModuleFR = addMesh(geometry, swerveModuleFRPos, swerveModuleFRRot);
					swerveModuleFR.name = "Swerve Drive";
					swerveModuleFR.vars = swerveModuleFL.vars;

					swerveModuleBL = addMesh(geometry, swerveModuleBLPos, swerveModuleBLRot);
					swerveModuleBL.name = "Swerve Drive";
					swerveModuleBL.vars = swerveModuleFL.vars;

					swerveModuleBR = addMesh(geometry, swerveModuleBRPos, swerveModuleBRRot);
					swerveModuleBR.name = "Swerve Drive";
					swerveModuleBR.vars = swerveModuleFL.vars;
				});

				meshLoader.load('./RobotModels/SwerveWheel.stl', function (geometry) {
					swerveWheelFL = addMesh(geometry, swerveWheelFLPos, swerveWheelFLRot);
					swerveWheelFL.name = "Swerve Drive";
					swerveWheelFL.vars = ["flSteerEncoderPos", "frSteerEncoderPos", "blSteerEncoderPos", "brSteerEncoderPos", "newLine", "flSteerEncoderConnected", "frSteerEncoderConnected", "blSteerEncoderConnected", "brSteerEncoderConnected", "newLine", "flSteerEncoderCalibrated", "frSteerEncoderCalibrated", "blSteerEncoderCalibrated", "brSteerEncoderCalibrated"];

					swerveWheelFR = addMesh(geometry, swerveWheelFRPos, swerveWheelFRRot);
					swerveWheelFR.name = "Swerve Drive";
					swerveWheelFR.vars = swerveWheelFL.vars;

					swerveWheelBL = addMesh(geometry, swerveWheelBLPos, swerveWheelBLRot);
					swerveWheelBL.name = "Swerve Drive";
					swerveWheelBL.vars = swerveWheelFL.vars;

					swerveWheelBR = addMesh(geometry, swerveWheelBRPos, swerveWheelBRRot);
					swerveWheelBR.name = "Swerve Drive";
					swerveWheelBR.vars - swerveWheelFR.vars;
				});

				meshLoader.load('./RobotModels/FieldHatchDropPanel.stl', function (geometry) {
					hatchDropOff = addMesh(geometry, hatchDropOffPos, hatchDropOffRot);
				});

				var cargoGeometry = new THREE.SphereGeometry(6.5, 32, 32);
				cargo = addMesh(cargoGeometry, new THREE.Vector3(0.0, 0.0, 10.0), new THREE.Euler(0.0, 0.0, 0.0));
				cargo.material.color.set(0xff6000);
				cargo.material.visible = false;

				meshLoader.load('./RobotModels/HatchPanel.stl', function (geometry) {
					hatchPanel = addMesh(geometry, new THREE.Vector3(0.6327691214493676, 18.422347864149888, 29.05109704451684), new THREE.Euler(0.0, 0.0, 0.0));
					hatchPanel.material.color.set(0xffff00);
					hatchPanel.material.visible = false;
				});

				var lineStripGeometry = new THREE.PlaneBufferGeometry(2.0, 70.0);
				lineStrip1 = addMesh(lineStripGeometry, lineStripPos, new THREE.Euler(-Math.PI/2, 0.0, 0.0));
				lineStrip2 = addMesh(lineStripGeometry, lineStripPos, new THREE.Euler(-Math.PI/2, 0.0, 0.0));
				lineStrip1.material.side = THREE.FrontSide;
				lineStrip2.material.side = THREE.FrontSide;

				// Lights
				scene.add(new THREE.HemisphereLight(0xffffff, 0x000000));
				var dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
				dirLight.position.set(250, 250, 0);
				scene.add(dirLight);
				var dirLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
				dirLight2.position.set(-250, -250, 0);
				scene.add(dirLight2);

				// Plane that helps to determine an intersection position
				intersectPlane = new THREE.Mesh(new THREE.PlaneBufferGeometry(5000, 5000, 8, 8), new THREE.MeshBasicMaterial({color: 0xffffff, visible: false}));
				scene.add(intersectPlane);

				// Objects for helping with dragging and dropping meshes
				raycaster = new THREE.Raycaster();
				offset = new THREE.Vector3();

				// World renderer
				renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.autoClear = false;

				renderer.gammaInput = true;
				renderer.gammaOutput = true;

				container.appendChild(renderer.domElement);

				axesHelper = new THREE.AxesHelper(50);
				scene.add(axesHelper);

				// Orbital controls for rotating and panning camera
				controls = new THREE.OrbitControls(camera, renderer.domElement);
				controls.target = cameraTarget;

				window.addEventListener('resize', onWindowResize, false);
				window.addEventListener('keydown', onKeyPressed, false);
				window.addEventListener('mousedown', onDocumentMouseDown, false);
        		window.addEventListener('mousemove', onDocumentMouseMove, false);
				window.addEventListener('mouseup', onDocumentMouseUp, false);

				window.onclick = function(event) {
					var modal = document.getElementById("modalData");
					if (event.target == modal) {
    					modal.style.display = "none";
  					}
				}

				try
				{
					NetworkTables.addWsConnectionListener(function(connected) {
      					console.log("Websocket connected: " + connected);
  					}, true);
				} catch(e) {}

				try
				{
					NetworkTables.addRobotConnectionListener(function(connected) {
						//Camera.Start('http://10.24.81.2:1181/?action=stream', 15);
						Camera.Start('http://10.24.81.11:5800', 10);
						//Camera.Start('http://127.0.0.1:8000/camera/mjpeg', 15);
					}, true);
				} catch(e) {}
			}

			function addMesh(geometry, position, rotation)
			{
				// Create different materials for each mesh so we can change them (and their colors) individually
				var meshMaterial = new THREE.MeshPhongMaterial({ color: 0xaaaaaa, specular: 0x111111, shininess: 200, side: THREE.DoubleSide });
				newMesh = new THREE.Mesh(geometry, meshMaterial);

				newMesh.rotation.copy(rotation);
				newMesh.position.copy(position);
					
				newMesh.originalPosition = position;
				meshes.push(newMesh);

				scene.add(newMesh);

				return newMesh;
			}

			function onWindowResize()
			{
				camera.aspect = (0.4*window.innerWidth) / window.innerHeight;
				camera.updateProjectionMatrix();

				camera2.aspect = (0.6*window.innerWidth) / (0.4*window.innerHeight);
				camera2.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function onDocumentMouseDown(event)
			{
				// Get mouse position
  				var mouseX = (event.clientX / (0.4*window.innerWidth)) * 2 - 1;
  				var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
  				// Get 3D vector from 3D mouse position using 'unproject' function
  				var vector = new THREE.Vector3(mouseX, mouseY, 1);
  				vector.unproject(camera);
  				// Set the raycaster position
  				raycaster.set(camera.position, vector.sub(camera.position).normalize());
  				// Find all intersected objects
  				var intersects = raycaster.intersectObjects(meshes);
  				if (intersects.length > 0) {
    				// Disable the controls
					controls.enableRotate = false;
    				// Set the selection - first intersected object
    				selection = intersects[0].object;
    				// Calculate the offset
    				var pIntersects = raycaster.intersectObject(intersectPlane);
    				offset.copy(pIntersects[0].point).sub(intersectPlane.position);
  				}
			}

			function onDocumentMouseMove(event)
			{
  				event.preventDefault();
  				// Get mouse position
  				var mouseX = (event.clientX / (0.4*window.innerWidth)) * 2 - 1;
  				var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
  				// Get 3D vector from 3D mouse position using 'unproject' function
  				var vector = new THREE.Vector3(mouseX, mouseY, 1);
  				vector.unproject(camera);
  				// Set the raycaster position
  				raycaster.set(camera.position, vector.sub(camera.position).normalize());
  				if (selection)
				{
					if(EDIT_MODE)
					{
						controls.enableRotate = false;
    					// Check the position where the plane is intersected
    					var intersects = raycaster.intersectObject(intersectPlane);
    					// Reposition the object based on the intersection point with the plane
    					selection.position.copy(intersects[0].point.sub(offset));
					}
					else
					{
						//If we're not in edit mode but we have a selection and moving the mouse, we must be trying to rotate
						selection = null;
						controls.enableRotate = true;
					}
  				}
				else
				{
					controls.enableRotate = true;
    				// Update position of the plane to always face the camera
    				var intersects = raycaster.intersectObjects(meshes);
    				if (intersects.length > 0)
					{
      					intersectPlane.position.copy(intersects[0].object.position);
      					intersectPlane.lookAt(camera.position);
    				}	
  				}
			}

			function onDocumentMouseUp(event)
			{
				if(selection != null && selection != undefined)
				{
					if(EDIT_MODE)
					{
						// With orbital controls, right-clicking to get to the console doesn't work (since right-clicking is panning)
						// So instead put the location data in a div at the top of the screen
						document.getElementById("positionData").innerHTML = selection.position.x + ", " + selection.position.y + ", " + selection.position.z;
					}
					else
					{
						if(selection.name != undefined && selection.name != "")
						{
							var modal = document.getElementById('modalData');
							modal.style.display = "block";
							modalContent.selectedItem = selection.name;
							modalContent.vars = selection.vars;
						}
					}
				}
				// Enable the controls
				controls.enableRotate = true;
				selection = null;
			}

			function onLoadNTFailed()
			{
				alert("Could not load Network Tables library, animation will not be available.  Did you access this page through the py2networktablesjs server?\nRun py2networktablesjs and navigate to http://127.0.0.1:8888");
			}

			function onKeyPressed(event)
			{
				if(event.ctrlKey && event.shiftKey && event.code == "KeyE")
				{
					EDIT_MODE = !EDIT_MODE;

					if(EDIT_MODE)
					{
						elevatorMid.originalPosition.addVectors(elevatorBase.originalPosition, elevatorMidOffset);
						elevatorTop.originalPosition.addVectors(elevatorMid.originalPosition, elevatorTopOffset);
						hatchSlide.originalPosition.addVectors(elevatorTop.originalPosition, hatchSlideOffset);
						resetMeshPositions();
						cargo.material.visible = false;
						hatchPanel.material.visible = false;
					}
					else
					{
						setMeshOriginalPositions();
					}
				}

				/*if(event.code == "KeyW")
				{
					var camDir = new THREE.Vector3();
					camera.getWorldDirection(camDir);
					camera.position.add(camDir.multiplyScalar(2.0));
				}

				if(event.code == "KeyS")
				{
					var camDir = new THREE.Vector3();
					camera.getWorldDirection(camDir);
					camera.position.sub(camDir.multiplyScalar(2.0));
				}*/
			}

			function setMeshOriginalPositions()
			{
				for(var i=0; i<meshes.length; i++)
				{
					meshes[i].originalPosition.copy(meshes[i].position);
				}
			}

			function resetMeshPositions()
			{
				for(var i=0; i<meshes.length; i++)
				{
					meshes[i].position.copy(meshes[i].originalPosition);
				}
			}

			function setSkyColor(col)
			{
				scene.background.set(col);
				scene.fog.color.set(col);
			}

			function animate()
			{
				try
				{
					// Set sky color depending on whether Network Tables is connected
					if(NetworkTables.isRobotConnected())
					{
						setSkyColor(0x009400);
					}
					else
					{
						setSkyColor(0x940000);
					}

					ntElevatorPos = NetworkTables.getValue("/SmartDashboard/ElevatorPos", 0.0);
					ntHatchSlidePos = NetworkTables.getValue("/SmartDashboard/HatchSlidePos", 0.0);
					ntIntakePos = NetworkTables.getValue("/SmartDashboard/CargoPos", 0.0) / 850.0;
					hasCargo = NetworkTables.getValue("/SmartDashboard/HasCargo", false);
					hasHatch = NetworkTables.getValue("/SmartDashboard/HasHatch", false);
					ntLineStrip1Pos = NetworkTables.getValue("/SmartDashboard/Teensy dist bright", 0.0) - 13.0;
					ntLineStrip2Pos = NetworkTables.getValue("/SmartDashboard/Teensy dist dim", 0.0) - 13.0;
					elevatorEncoderConnected = NetworkTables.getValue("/SmartDashboard/IsElevatorEncoderConnected", false);
					elevatorZeroed = NetworkTables.getValue("/SmartDashboard/IsElevatorZeroed", false);
					intakeEncoderConnected = NetworkTables.getValue("/SmartDashboard/IsCargoIntakeEncoderConnected", false);
					intakeZeroed = NetworkTables.getValue("/SmartDashboard/IsCargoIntakeZeroed", false);
					slideEncoderConnected = NetworkTables.getValue("/SmartDashboard/slideEncConnnected", false);
					slideZeroed = NetworkTables.getValue("/SmartDashboard/IsHatchZeroed", false);
					flSteerEncoderConnected = NetworkTables.getValue("/SmartDashboard/FL steer encoder connected", false);
					frSteerEncoderConnected = NetworkTables.getValue("/SmartDashboard/FR steer encoder connected", false);
					blSteerEncoderConnected = NetworkTables.getValue("/SmartDashboard/BL steer encoder connected", false);
					brSteerEncoderConnected = NetworkTables.getValue("/SmartDashboard/BR steer encoder connected", false);
					flSteerEncoderCalibrated = NetworkTables.getValue("/SmartDashboard/FLSteerEncCalibrated", false);
					frSteerEncoderCalibrated = NetworkTables.getValue("/SmartDashboard/FRSteerEncCalibrated", false);
					blSteerEncoderCalibrated = NetworkTables.getValue("/SmartDashboard/BLSteerEncCalibrated", false);
					brSteerEncoderCalibrated = NetworkTables.getValue("/SmartDashboard/BRSteerEncCalibrated", false);
					flSteerEncoderPos = NetworkTables.getValue("/SmartDashboard/FL Steer encoder pos", 0.0) * Math.PI/180.0;
					frSteerEncoderPos = NetworkTables.getValue("/SmartDashboard/FR Steer encoder pos", 0.0) * Math.PI/180.0;
					blSteerEncoderPos = NetworkTables.getValue("/SmartDashboard/BL Steer encoder pos", 0.0) * Math.PI/180.0;
					brSteerEncoderPos = NetworkTables.getValue("/SmartDashboard/BR Steer encoder pos", 0.0) * Math.PI/180.0;

					gyroYaw = NetworkTables.getValue("/SmartDashboard/Gyro yaw", 0.0);

					LL_vis = NetworkTables.getValue("/limelight/tv", 0);
					LL_ty = NetworkTables.getValue("/limelight/ty", 0.0);
					LL_ydist = 15.75*Math.tan((58.04+LL_ty)*Math.PI/180.0) - 20.0; //NetworkTables.getValue("/SmartDashboard/distance ", 14.0);
					LL_tx = NetworkTables.getValue("/limelight/tx", 0.0);
					LL_skew = NetworkTables.getValue("/limelight/ts", 0.0);
					if(LL_skew < -45) LL_skew += 90.0;
					//LL_xdist = Math.tan(LL_tx*Math.PI/180.0)*LL_ydist;
					LL_xdist = LL_ydist*Math.tan((LL_tx-LL_skew*5.0)*Math.PI/180.0);
					//var camtran = [];
					//camtran = NetworkTables.getValue("/limelight/camtran", []);
				}
				catch(e)
				{
					setSkyColor(0x940000);
				}

				// No animation in edit mode, makes it difficult to grab onto meshes and move them
				if(!EDIT_MODE)
				{
					axesHelper.visible = false;

					try
					{
						cargoIntakeAssembly.position.setZ(intakePos.z + ntIntakePos);

						var newElevatorMidPos = new THREE.Vector3();
						newElevatorMidPos.addVectors(elevatorBase.position, elevatorMidOffset);
						newElevatorMidPos.setY(newElevatorMidPos.y + ntElevatorPos/2.0);
						elevatorMid.position.copy(newElevatorMidPos);

						var newElevatorTopPos = new THREE.Vector3();
						newElevatorTopPos.addVectors(elevatorMid.position, elevatorTopOffset);
						newElevatorTopPos.setY(newElevatorTopPos.y + ntElevatorPos/2.0);
						elevatorTop.position.copy(newElevatorTopPos);

						var newHatchSlidePos = new THREE.Vector3();
						newHatchSlidePos.addVectors(elevatorTop.position, hatchSlideOffset);
						newHatchSlidePos.setX(newHatchSlidePos.x - ntHatchSlidePos);
						hatchSlide.position.copy(newHatchSlidePos);

						cargo.position.addVectors(newHatchSlidePos, cargoOffset);
						cargo.material.visible = hasCargo;

						hatchPanel.position.addVectors(newHatchSlidePos, hatchOffset);
						hatchPanel.material.visible = hasHatch;

						lineStrip1.position.setX(lineStripPos.x - ntLineStrip1Pos);
						lineStrip2.position.setX(lineStripPos.x - ntLineStrip2Pos);
						lineStrip1.material.visible = (ntLineStrip1Pos < 15);
						lineStrip2.material.visible = (ntLineStrip2Pos < 15);

						elevatorColor = (elevatorEncoderConnected && elevatorZeroed) ? 0xaaaaaa : (elevatorEncoderConnected ? 0xff6000 : 0xff0000);
						elevatorBase.material.color.set(elevatorColor);
						elevatorMid.material.color.set(elevatorColor);
						elevatorTop.material.color.set(elevatorColor);

						intakeColor = (intakeEncoderConnected && intakeZeroed) ? 0xaaaaaa : (intakeEncoderConnected ? 0xff6000 : 0xff0000);
						cargoIntakeAssembly.material.color.set(intakeColor);

						slideColor = (slideEncoderConnected && slideZeroed) ? 0xaaaaaa : (slideEncoderConnected ? 0xff6000 : 0xff0000);
						hatchSlide.material.color.set(slideColor);

						var flColor = (flSteerEncoderConnected && flSteerEncoderCalibrated) ? 0xaaaaaa : (flSteerEncoderConnected ? 0xff6000 : 0xff0000);
						swerveModuleFL.material.color.set(flColor);
						swerveWheelFL.material.color.set(flColor);
						swerveWheelFL.rotation.z = flSteerEncoderPos;

						var frColor = (frSteerEncoderConnected && frSteerEncoderCalibrated) ? 0xaaaaaa : (frSteerEncoderConnected ? 0xff6000 : 0xff0000);
						swerveModuleFR.material.color.set(frColor);
						swerveWheelFR.material.color.set(frColor);
						swerveWheelFR.rotation.z = frSteerEncoderPos;

						var blColor = (blSteerEncoderConnected && blSteerEncoderCalibrated) ? 0xaaaaaa : (blSteerEncoderConnected ? 0xff6000 : 0xff0000);
						swerveModuleBL.material.color.set(blColor);
						swerveWheelBL.material.color.set(blColor);
						swerveWheelBL.rotation.z = blSteerEncoderPos;

						var brColor = (brSteerEncoderConnected && brSteerEncoderCalibrated) ? 0xaaaaaa : (brSteerEncoderConnected ? 0xff6000 : 0xff0000);
						swerveModuleBR.material.color.set(brColor);
						swerveWheelBR.material.color.set(brColor);
						swerveWheelBR.rotation.z = brSteerEncoderPos;

						hatchDropOff.position.setZ(hatchDropOffPos.z + LL_ydist);
						hatchDropOff.position.setX(hatchDropOffPos.x - LL_xdist);
						hatchDropOff.rotation.z = hatchDropOffRot.z;
						hatchDropOff.rotateZ(-LL_skew*Math.PI/180.0);
						hatchDropOff.material.visible = (LL_vis == 1) ? true : false;
					}
					catch(e)
					{
						// One of the meshes hasn't loaded yet, no need to crash and burn... just wait and the model will load soon
					}
				}
				else
				{
					axesHelper.visible = true;
				}

				if(meshes.length < numMeshes)
				{
					// Sometimes not all meshes load properly.  This should be fixed
					// But on the off-chance it's not, make the sky orange to indicate the problem.  Fixable with page refresh
					// Doubles as indicator of "Still loading..."
					setSkyColor(0xff6000);
				}

				//Update modal
				if(modalContent.selectedItem != undefined)
				{
					modalContent.innerHTML = "<b>" + modalContent.selectedItem + "</b><br/>";
					if(modalContent.vars != undefined)
					{
						for(var i = 0; i < modalContent.vars.length; i++)
						{
							modalContent.innerHTML + "<br/>";
							if(modalContent.vars[i] != "newLine")
							{
								modalContent.innerHTML += "<br/>" + modalContent.vars[i] + ": " + window[modalContent.vars[i]];
							}
						}
					}
					else
					{
						modalContent.innerHTML += "<br/>Not tracking any variables for <i>" + modalContent.selectedItem + "</i>.";
					}
				}
				
				requestAnimationFrame(animate);

				render();
			}

			function render()
			{
				controls.update();

				var origSkyCol = scene.background.color;

				renderer.clear();
				renderer.setViewport(0, 0, 0.4*window.innerWidth, window.innerHeight);
				renderer.setScissor(0, 0, 0.4*window.innerWidth, window.innerHeight);
				renderer.setScissorTest(true);
				renderer.render(scene, camera);

				setSkyColor(0x000000);
				plane.material.visible = false;
				mirror.material.visible = false;
				renderer.setViewport(0.4*window.innerWidth, 0.6*window.innerHeight, 0.6*window.innerWidth, 0.4*window.innerHeight);
				renderer.setScissor(0.4*window.innerWidth, 0.6*window.innerHeight, 0.6*window.innerWidth, 0.4*window.innerHeight);
				renderer.setScissorTest(true);
				renderer.render(scene, camera2);
				plane.material.visible = true;
				mirror.material.visible = true;
				setSkyColor(origSkyCol);

				//renderer.setViewport()
			}

		</script>
	</body>
</html>
